<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>井字遊戲</title>
  </head>
  <style>
    * {
      padding: 0;
      margin: 0;
      box-sizing: border-box;
      margin: auto;
    }
    .container {
      width: 600px;
      display: flex;
      flex-wrap: wrap;
    }
    .lattice {
      width: 200px;
      height: 200px;
      border: 1px solid black;
    }
    .player1,
    .player2 {
      text-align: center;
      line-height: 200px;
    }
    .player1 {
      background-color: blue;
    }
    .player1::before {
      content: "O";
      color: white;
      font-size: 200px;
    }
    .player2 {
      background-color: red;
    }
    .player2::before {
      content: "X";
      color: white;
      font-size: 200px;
    }
    .button {
      text-align: center;
      margin: 10px;
    }
    .button button {
      padding: 10px;
      font-size: 18px;
    }
  </style>
  <body>
    <div id="app">
      <div class="container">
        <div
          class="lattice"
          v-for="item in block"
          :class="{player1:player1.includes(item.val),player2:player2.includes(item.val)}"
          @click="playChess(item)"
        ></div>
      </div>
      <div class="button">
        <button @click="reset">重開開始</button>
      </div>
    </div>

    <script src="./vue.js"></script>
    <script>
      const app = Vue.createApp({
        data() {
          return {
            condition: "123,456,789,147,258,369,159,357",
            block: [
              { select: false, val: 1 },
              { select: false, val: 2 },
              { select: false, val: 3 },
              { select: false, val: 4 },
              { select: false, val: 5 },
              { select: false, val: 6 },
              { select: false, val: 7 },
              { select: false, val: 8 },
              { select: false, val: 9 },
            ],
            player1: [],
            player2: [],
            currPlayer: 1,
            playing: false,
            over: false,
          };
        },
        watch: {
          player1: {
            handler(newVal) {
              console.log(newVal);
              if (this.checkEWin(newVal)) {
                alert("player1勝利");
                this.over = true;
              }
            },
            deep: true,
          },
          player2: {
            handler(newVal) {
              if (this.checkEWin(newVal)) {
                alert("player2勝利");
                this.over = true;
              }
            },
            deep: true,
          },
        },
        methods: {
          playChess(item) {
            if (this.playing || this.over) return;
            if (
              this.player1.includes(item.val) ||
              this.player2.includes(item.val)
            ) {
              alert("不可重複下棋");
              return;
            }
            item.select = true;
            this.player1.push(item.val);
            this.playing = true;
            setTimeout(() => {
              this.countScore();
            }, 500);

            this.currPlayer = this.currPlayer == 1 ? -1 : 1;
          },
          checkEWin(player) {
            let win = this.condition.split(",");
            let conditionMet = 0;
            for (let i = 0; i < win.length; i++) {
              conditionMet = 0;

              for (let j = 0; j < win[i].length; j++) {
                if (player.includes(win[i][j] * 1)) {
                  conditionMet++;
                }
              }
              if (conditionMet >= 3) {
                return true;
                break;
              }
            }

            if (
              this.player1.length + this.player2.length ==
              this.block.length
            ) {
              alert("平局");
              this.over = true;
            }
          },
          countScore() {
            let selected = this.block
              .filter((item) => !item.select)
              .map((item) => item.val);

            let bestScore = -Infinity;
            let bestMove;

            let offensiveWeight = 1.5; // 进攻权重
            let defensiveWeight = 1.0; // 防守权重

            for (let i = 0; i < this.block.length; i++) {
              if (!selected.includes(this.block[i].val)) continue;

              this.player1.push(this.block[i].val);
              let player1Score = this.evaluatePosition(
                [...this.player1],
                this.player2
              );
              this.player1.pop();

              this.player2.push(this.block[i].val);
              let player2Score = this.evaluatePosition(
                [...this.player2],
                this.player1
              );
              this.player2.pop();
              let score =
                player2Score * offensiveWeight + player1Score * defensiveWeight;
              //   let score = player2Score + player1Score;

              if (score > bestScore) {
                bestScore = score;
                bestMove = this.block[i];
              }
            }

            if (bestMove) {
              this.player2.push(bestMove.val);
              bestMove.select = true;
              this.playing = false;
            }
          },
          evaluatePosition(curr, opponent) {
            // console.log("curr", curr);
            let win = this.condition.split(",");
            let score = 0;

            for (let i = 0; i < win.length; i++) {
              let conditionMet = 0;
              let blocked = false;

              for (let j = 0; j < win[i].length; j++) {
                if (opponent.includes(win[i][j] * 1)) {
                  blocked = true;
                } else if (curr.includes(win[i][j] * 1)) {
                  conditionMet++;
                  if (conditionMet >= 3) {
                    score += 1000;
                  }
                }
              }

              if (!blocked) {
                // 如果当前玩家即将完成这一获胜条件，给予高分
                if (conditionMet == win[i].length - 1) {
                  score += 100;
                } else {
                  score += conditionMet / win[i].length;
                }
              }
            }

            return score;
          },
          reset() {
            let check = confirm("確定刷新?");
            if (check) {
              this.playing = false;
              this.over = false;
              this.player1 = [];
              this.player2 = [];
            }
          },
        },
        mounted() {
        },
      }).mount("#app");
    </script>
  </body>
</html>
